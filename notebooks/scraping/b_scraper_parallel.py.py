import warnings

warnings.filterwarnings("ignore")


import os
from concurrent.futures import ThreadPoolExecutor, as_completed

import pandas as pd
import requests
from tqdm import tqdm

# üîß Par√°metro: n√∫mero de descargas simult√°neas
MAX_WORKERS = 5
TIMEOUT = 200  # segundos

# üìÇ Archivos de entrada
DATA_FILE = "nombres_archivos.csv"
LOG_FILE = "download_log.txt"
DOWNLOAD_DIR = "downloads"

# Crear carpeta de destino si no existe
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# Leer el DataFrame desde el TXT
try:
    df_result = pd.read_csv(
        DATA_FILE, sep=",", encoding="utf-8"
    )  # usa utf-8 para evitar errores de caracteres
except Exception as e:
    print(f"‚ùå Error al leer '{DATA_FILE}': {e}")
    exit(1)

# Verificar que existan columnas necesarias
required_cols = {"file_name", "clean_link"}
if not required_cols.issubset(df_result.columns):
    print(f"‚ùå El archivo debe contener las columnas: {required_cols}")
    exit(1)

# Leer el √≠ndice de reanudaci√≥n
last_index = 0
if os.path.exists(LOG_FILE):
    with open(LOG_FILE, "r") as log:
        log_data = log.read().strip()
        if log_data.isdigit():
            last_index = int(log_data)
            print(f"üîÑ Reanudando desde el √≠ndice {last_index}")
        else:
            print("‚ö†Ô∏è Log mal formado. Iniciando desde cero.")
else:
    print("üÜï No se encontr√≥ log. Iniciando desde cero.")

# Subconjunto pendiente por descargar
total_archivos = len(df_result)
df_to_download = df_result.iloc[last_index:]


# Funci√≥n de descarga
def download_file(index, row):
    file_name = row["file_name"]
    file_path = os.path.join(DOWNLOAD_DIR, file_name)
    url = row["clean_link"]

    try:
        response = requests.get(url, verify=False, timeout=TIMEOUT)
        if response.status_code == 200:
            with open(file_path, "wb") as f:
                f.write(response.content)
            return index, True, None
        else:
            return index, False, f"HTTP {response.status_code}"
    except requests.exceptions.RequestException as e:
        return index, False, str(e)


# Descarga paralela con barra de progreso
with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
    futures = {
        executor.submit(download_file, index, row): index
        for index, row in df_to_download.iterrows()
    }

    for future in tqdm(as_completed(futures), total=len(futures), desc="üì• Descargando archivos"):
        index, success, error = future.result()
        if success:
            # Guardar el √≠ndice del siguiente archivo
            with open(LOG_FILE, "w") as log:
                log.write(str(index + 1))
        else:
            print(f"‚ö†Ô∏è Error en √≠ndice {index}: {error}")
